"""
Pytest File Generator
=====================
Converts JSON test cases into executable pytest files.

Usage:
    from backend.model.LLM.pytest_generator import generate_pytest_file
    
    filepath = generate_pytest_file(
        tests=prioritized_tests,
        output_dir="generated_tests",
        filename="test_login.py"
    )
"""

import os
import re
import json
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)

# Default output directory
DEFAULT_OUTPUT_DIR = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))),  # project root
    "generated_tests"
)


class PytestGenerator:
    """
    Generates executable pytest files from test case definitions.
    
    Features:
    - Creates properly formatted pytest files
    - Includes fixtures for API testing
    - Adds parametrization for similar tests
    - Generates coverage configuration
    """
    
    PYTEST_HEADER = '''"""
{description}

Auto-generated by ETTA-X Test Pipeline
Generated: {timestamp}
Repository: {repository}
Commit: {commit}

Run with:
    pytest {filename} -v --tb=short
"""

import pytest
import requests
import json
from typing import Dict, Any

# Base URL - configure this for your environment
BASE_URL = "{base_url}"


@pytest.fixture(scope="module")
def api_client():
    """Create a session for API tests."""
    session = requests.Session()
    session.headers.update({{
        "Content-Type": "application/json",
        "Accept": "application/json"
    }})
    yield session
    session.close()


@pytest.fixture
def auth_token(api_client):
    """Get authentication token if needed."""
    # Override this fixture if authentication is required
    return None


'''

    TEST_TEMPLATE = '''
class Test{class_name}:
    """Tests for {endpoint}"""
    
{test_methods}
'''

    TEST_METHOD_TEMPLATE = '''    @pytest.mark.{category}
    def {test_name}(self, api_client{auth_param}):
        """
        {description}
        
        Priority Score: {priority_score:.2%}
        Expected Status: {expected_status}
        """
        url = f"{{BASE_URL}}{endpoint}"
        {method_call}
        
        assert response.status_code == {expected_status}, \\
            f"Expected {expected_status}, got {{response.status_code}}. Response: {{response.text[:200]}}"
        
        # Additional assertions
        {additional_assertions}
'''

    def __init__(
        self,
        output_dir: Optional[str] = None,
        base_url: str = "http://localhost:8000"
    ):
        """
        Initialize the pytest generator.
        
        Args:
            output_dir: Directory to write generated test files
            base_url: Base URL for API tests
        """
        self.output_dir = Path(output_dir or DEFAULT_OUTPUT_DIR)
        self.base_url = base_url
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def _sanitize_name(self, name: str) -> str:
        """Convert name to valid Python identifier."""
        # Replace non-alphanumeric with underscore
        name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure starts with letter
        if name and name[0].isdigit():
            name = 'test_' + name
        return name.lower()
    
    def _get_class_name(self, endpoint: str) -> str:
        """Generate class name from endpoint."""
        # Extract meaningful part of endpoint
        parts = [p for p in endpoint.split('/') if p and not p.startswith('{')]
        if parts:
            # Capitalize each part
            return ''.join(p.capitalize() for p in parts[:2])
        return "Api"
    
    def _generate_method_call(self, method: str, payload: Dict[str, Any]) -> str:
        """Generate the requests method call."""
        method_lower = method.lower()
        
        if payload and method_lower in ['post', 'put', 'patch']:
            payload_str = json.dumps(payload, indent=12)
            return f'''payload = {payload_str}
        response = api_client.{method_lower}(url, json=payload)'''
        elif method_lower == 'delete':
            return f'response = api_client.delete(url)'
        else:
            return f'response = api_client.get(url)'
    
    def _generate_assertions(self, expected_status: int) -> str:
        """Generate additional assertions based on expected status."""
        assertions = []
        
        if expected_status == 200:
            assertions.append("# Verify response is valid JSON")
            assertions.append("try:")
            assertions.append("    data = response.json()")
            assertions.append("    assert data is not None")
            assertions.append("except json.JSONDecodeError:")
            assertions.append("    pass  # Response may not be JSON")
        elif expected_status == 201:
            assertions.append("# Verify created resource")
            assertions.append("data = response.json()")
            assertions.append("assert 'id' in data or data is not None")
        elif expected_status == 400:
            assertions.append("# Verify error response")
            assertions.append("data = response.json()")
            assertions.append("assert 'error' in data or 'message' in data or 'detail' in data")
        elif expected_status == 401:
            assertions.append("# Verify unauthorized response")
            assertions.append("pass  # 401 status is sufficient validation")
        elif expected_status == 404:
            assertions.append("# Verify not found")
            assertions.append("pass  # 404 status is sufficient validation")
        else:
            assertions.append("pass  # Status code assertion is sufficient")
        
        return '\n        '.join(assertions)
    
    def _generate_test_method(self, test: Dict[str, Any]) -> str:
        """Generate a single test method."""
        name = self._sanitize_name(test.get('name', 'test_case'))
        if not name.startswith('test_'):
            name = f'test_{name}'
        
        endpoint = test.get('endpoint', '/')
        method = test.get('method', 'GET').upper()
        payload = test.get('payload', {})
        expected_status = test.get('expected_status', 200)
        description = test.get('description', f"Test {method} {endpoint}")
        priority_score = test.get('priority_score', 0.5)
        category = test.get('category', 'functional')
        
        # Check if auth is needed (based on endpoint or category)
        needs_auth = any(x in endpoint.lower() or x in category.lower() 
                        for x in ['auth', 'user', 'admin', 'protected'])
        auth_param = ", auth_token" if needs_auth else ""
        
        method_call = self._generate_method_call(method, payload)
        additional_assertions = self._generate_assertions(expected_status)
        
        return self.TEST_METHOD_TEMPLATE.format(
            test_name=name,
            description=description,
            endpoint=endpoint,
            method_call=method_call,
            expected_status=expected_status,
            additional_assertions=additional_assertions,
            auth_param=auth_param,
            priority_score=priority_score,
            category=category
        )
    
    def generate(
        self,
        tests: List[Dict[str, Any]],
        filename: Optional[str] = None,
        repository: str = "unknown",
        commit: str = "unknown",
        description: str = "Auto-generated API Tests"
    ) -> str:
        """
        Generate a pytest file from test definitions.
        
        Args:
            tests: List of test case dictionaries
            filename: Output filename (without .py)
            repository: Repository name for documentation
            commit: Commit hash for documentation
            description: Description for the test file
            
        Returns:
            Path to the generated file
        """
        if not tests:
            raise ValueError("No tests provided")
        
        # Generate filename if not provided
        if not filename:
            # Use first endpoint to generate name
            first_endpoint = tests[0].get('endpoint', '/api')
            clean_endpoint = re.sub(r'[^a-zA-Z0-9]', '_', first_endpoint)
            filename = f"test_{clean_endpoint.strip('_')}"
        
        if not filename.endswith('.py'):
            filename = f"{filename}.py"
        
        # Group tests by endpoint for class organization
        endpoint_groups: Dict[str, List[Dict]] = {}
        for test in tests:
            endpoint = test.get('endpoint', '/')
            if endpoint not in endpoint_groups:
                endpoint_groups[endpoint] = []
            endpoint_groups[endpoint].append(test)
        
        # Generate header
        content = self.PYTEST_HEADER.format(
            description=description,
            timestamp=datetime.now().isoformat(),
            repository=repository,
            commit=commit,
            filename=filename,
            base_url=self.base_url
        )
        
        # Generate test classes
        for endpoint, endpoint_tests in endpoint_groups.items():
            class_name = self._get_class_name(endpoint)
            
            # Generate test methods
            methods = []
            for test in endpoint_tests:
                methods.append(self._generate_test_method(test))
            
            content += self.TEST_TEMPLATE.format(
                class_name=class_name,
                endpoint=endpoint,
                test_methods=''.join(methods)
            )
        
        # Write file
        filepath = self.output_dir / filename
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Generated pytest file: {filepath}")
        return str(filepath)
    
    def generate_conftest(self) -> str:
        """Generate a conftest.py with shared fixtures."""
        content = '''"""
Shared pytest fixtures for ETTA-X generated tests.
"""

import pytest
import requests
import os

# Read base URL from environment or use default
BASE_URL = os.environ.get("TEST_BASE_URL", "http://localhost:8000")


@pytest.fixture(scope="session")
def base_url():
    """Base URL for API tests."""
    return BASE_URL


@pytest.fixture(scope="session")
def api_session():
    """Create a persistent session for all tests."""
    session = requests.Session()
    session.headers.update({
        "Content-Type": "application/json",
        "Accept": "application/json"
    })
    yield session
    session.close()


@pytest.fixture
def api_client(api_session, base_url):
    """API client with base URL configured."""
    api_session.base_url = base_url
    return api_session


# Custom markers
def pytest_configure(config):
    """Register custom markers."""
    config.addinivalue_line("markers", "authentication: Authentication tests")
    config.addinivalue_line("markers", "security: Security tests")
    config.addinivalue_line("markers", "crud: CRUD operation tests")
    config.addinivalue_line("markers", "error_handling: Error handling tests")
    config.addinivalue_line("markers", "edge_case: Edge case tests")
    config.addinivalue_line("markers", "happy_path: Happy path tests")
    config.addinivalue_line("markers", "functional: General functional tests")
'''
        
        filepath = self.output_dir / "conftest.py"
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Generated conftest.py: {filepath}")
        return str(filepath)
    
    def generate_pytest_ini(self) -> str:
        """Generate pytest.ini configuration."""
        content = '''[pytest]
testpaths = .
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Output settings
addopts = -v --tb=short --strict-markers

# Markers
markers =
    authentication: Tests for authentication flows
    security: Security-related tests
    crud: CRUD operation tests
    error_handling: Error handling tests
    edge_case: Edge case tests
    happy_path: Happy path tests
    functional: General functional tests

# Logging
log_cli = true
log_cli_level = INFO
'''
        
        filepath = self.output_dir / "pytest.ini"
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Generated pytest.ini: {filepath}")
        return str(filepath)


# Convenience function
def generate_pytest_file(
    tests: List[Dict[str, Any]],
    output_dir: Optional[str] = None,
    filename: Optional[str] = None,
    base_url: str = "http://localhost:8000",
    repository: str = "unknown",
    commit: str = "unknown"
) -> Dict[str, Any]:
    """
    Generate pytest file from test cases.
    
    Args:
        tests: List of test case dictionaries
        output_dir: Output directory
        filename: Output filename
        base_url: Base URL for API tests
        repository: Repository name
        commit: Commit hash
        
    Returns:
        Dictionary with generated file paths
    """
    generator = PytestGenerator(output_dir=output_dir, base_url=base_url)
    
    # Generate main test file
    test_file = generator.generate(
        tests=tests,
        filename=filename,
        repository=repository,
        commit=commit
    )
    
    # Generate supporting files
    conftest_file = generator.generate_conftest()
    pytest_ini = generator.generate_pytest_ini()
    
    return {
        "test_file": test_file,
        "conftest_file": conftest_file,
        "pytest_ini": pytest_ini,
        "output_dir": str(generator.output_dir),
        "test_count": len(tests)
    }


# CLI for testing
if __name__ == "__main__":
    import json
    
    # Sample tests
    sample_tests = [
        {
            "name": "test_valid_login",
            "endpoint": "/api/login",
            "method": "POST",
            "payload": {"username": "valid", "password": "valid"},
            "expected_status": 200,
            "category": "authentication",
            "description": "Test valid login returns token",
            "priority_score": 0.92
        },
        {
            "name": "test_invalid_password",
            "endpoint": "/api/login",
            "method": "POST",
            "payload": {"username": "valid", "password": "wrong"},
            "expected_status": 401,
            "category": "authentication",
            "description": "Test invalid password returns 401",
            "priority_score": 0.88
        },
        {
            "name": "test_missing_username",
            "endpoint": "/api/login",
            "method": "POST",
            "payload": {"password": "valid"},
            "expected_status": 400,
            "category": "error_handling",
            "description": "Test missing username returns 400",
            "priority_score": 0.75
        }
    ]
    
    print("="*60)
    print("Pytest File Generator Demo")
    print("="*60)
    
    result = generate_pytest_file(
        tests=sample_tests,
        output_dir="./demo_tests",
        filename="test_login",
        repository="test/repo",
        commit="abc123"
    )
    
    print(f"\nGenerated files:")
    for key, value in result.items():
        print(f"  {key}: {value}")
    
    # Show generated content
    print(f"\n--- {result['test_file']} ---")
    with open(result['test_file'], 'r') as f:
        print(f.read()[:2000] + "...")
